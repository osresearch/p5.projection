<!DOCTYPE html>
<html>
  <head>
<title>Projection mapped chessboard demo - p5.projection</title>
<meta property="og:title" content="Projection mapped chessboard demo">
<meta property="og:site_name" content="p5.projection">
<meta property="og:url" content="https://osresearch.github.io/p5.projection/examples/chessboard.html">
<meta property="og:description" content="Demo of the projection mapping library for p5js. Click to set the corners and adjust for skew.">
<meta property="og:image" content="https://osresearch.github.io/p5.projection/images/chessboard.png">

    <meta name="viewport" width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0>
    <style> body {padding: 0; margin: 0;} </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.3.1/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/9.5.1/math.js"></script>
    <script src="../library/p5.projection.js"></script>
  </head>
<a href="../">Back to the p5.projection overview</a>
  <body>
<script>
let font;
let mat = new ProjectionMatrix();

function preload()
{
	font = loadFont("../assets/Inconsolata-Regular.ttf");
}

function setup()
{
	frameRate(25);
	createCanvas(windowWidth-10, windowHeight-10, WEBGL);
	background(255);
}

function draw()
{
	background(0);

	// apply the translation matrix with debug turned on
	mat.apply(2);

	// draw some text to show that it is also affected by the rendering
	textFont(font, 200);
	noStroke();
	fill(80);
	text("Projection test", 100, 200);

	// draw a checkerboard pattern centered on the screen
	push();
	translate((1920 - 800)/2, (1080 - 800)/2 + 100);

	stroke(100);
	noFill();
	rect(0, 0, 800, 800);

	noStroke();
	fill(255);
	for(let y=0 ; y < 8 ; y++)
		for(let x = (y&1) ; x < 8 ; x+=2)
			rect(x*100, y*100, 100, 100);
	pop();
}


function mouseClicked(event)
{
	// in webgl mode (0,0) is the *center* of the screen
	const x = mouseX - width/2;
	const y = mouseY - height/2;
	const corner =
		x < 0 && y < 0 ? 0 :
		x < 0 && y > 0 ? 1 :
		x > 0 && y < 0 ? 2 :
		x > 0 && y > 0 ? 3 :
		0;

	// the outPts are the corner in screen coordinates
	mat.outPts[corner][0] = int(x);
	mat.outPts[corner][1] = int(y);

	// compute the forward and inverse projection matrices
	mat.update();
	//console.log("corner", n, "x=", x, "y=", y, "mat=", mat);
}


</script>
  </body>
</html>
